--- indicators_1137.ts	2026-02-14 17:08:55.011803385 +0100
+++ src/utils/indicators.ts	2026-02-14 13:47:33.522153532 +0100
@@ -169,6 +169,71 @@
     return result;
   },
 
+  vwma(
+    price: NumberArray,
+    volume: NumberArray,
+    period: number,
+    out?: Float64Array
+  ): Float64Array {
+    const len = price.length;
+    const result = (out && out.length === len) ? out : new Float64Array(len);
+    result.fill(NaN);
+
+    if (len < period) return result;
+
+    let sumPv = 0;
+    let sumV = 0;
+
+    for (let i = 0; i < period; i++) {
+        sumPv += price[i] * volume[i];
+        sumV += volume[i];
+    }
+
+    result[period - 1] = sumV === 0 ? 0 : sumPv / sumV;
+
+    for (let i = period; i < len; i++) {
+        const dropPv = price[i - period] * volume[i - period];
+        const dropV = volume[i - period];
+        const addPv = price[i] * volume[i];
+        const addV = volume[i];
+
+        sumPv = sumPv - dropPv + addPv;
+        sumV = sumV - dropV + addV;
+
+        result[i] = sumV === 0 ? 0 : sumPv / sumV;
+    }
+
+    return result;
+  },
+
+  hma(
+    data: NumberArray,
+    period: number,
+    out?: Float64Array,
+  ): Float64Array {
+    const len = data.length;
+    const result = (out && out.length === len) ? out : new Float64Array(len);
+    result.fill(NaN);
+
+    if (len < period) return result;
+
+    // HMA = WMA(2 * WMA(n/2) - WMA(n), sqrt(n))
+    const halfPeriod = Math.floor(period / 2);
+    const sqrtPeriod = Math.floor(Math.sqrt(period));
+
+    const wmaHalf = this.wma(data, halfPeriod);
+    const wmaFull = this.wma(data, period);
+    const combined = new Float64Array(len);
+
+    for(let i=0; i<len; i++) {
+        combined[i] = 2 * wmaHalf[i] - wmaFull[i];
+    }
+
+    return this.wma(combined, sqrtPeriod, result);
+  },
+
+
+
   rsi(
     data: NumberArray,
     period: number,
@@ -1574,4 +1639,355 @@
     const res = JSIndicators.ema(nums, period);
     return new Decimal(res[res.length - 1]);
   },
+
+  calculateWMA(
+    data: (number | string | Decimal)[],
+    period: number,
+  ): Decimal | null {
+    if (data.length < period) return null;
+    const nums = data.map((p) => toNumFast(p));
+    const res = JSIndicators.wma(nums, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateVWMA(
+    prices: (number | string | Decimal)[],
+    volumes: (number | string | Decimal)[],
+    period: number,
+  ): Decimal | null {
+    if (prices.length < period) return null;
+    const p = prices.map((v) => toNumFast(v));
+    const v = volumes.map((v) => toNumFast(v));
+    const res = JSIndicators.vwma(p, v, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateHMA(
+    data: (number | string | Decimal)[],
+    period: number,
+  ): Decimal | null {
+    if (data.length < period) return null;
+    const nums = data.map((p) => toNumFast(p));
+    const res = JSIndicators.hma(nums, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateMACD(
+    data: (number | string | Decimal)[],
+    fast: number = 12,
+    slow: number = 26,
+    signal: number = 9,
+  ) {
+    if (data.length < slow) return null;
+    const nums = data.map((p) => toNumFast(p));
+    const res = JSIndicators.macd(nums, fast, slow, signal);
+    const idx = res.macd.length - 1;
+    return {
+      macd: new Decimal(res.macd[idx]),
+      signal: new Decimal(res.signal[idx]),
+      histogram: new Decimal(res.macd[idx] - res.signal[idx]),
+    };
+  },
+
+  calculateStochastic(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    kPeriod: number = 14,
+    dPeriod: number = 3,
+    kSmoothing: number = 3,
+  ) {
+    if (close.length < kPeriod) return null;
+    const h = high.map((v) => toNumFast(v));
+    const l = low.map((v) => toNumFast(v));
+    const c = close.map((v) => toNumFast(v));
+
+    let kLine = JSIndicators.stoch(h, l, c, kPeriod);
+
+    // Smoothing K
+    let smoothedK = kLine;
+    if (kSmoothing > 1) {
+      smoothedK = JSIndicators.sma(kLine, kSmoothing);
+    }
+
+    // D
+    const dLine = JSIndicators.sma(smoothedK, dPeriod);
+
+    const idx = kLine.length - 1;
+    return {
+      k: new Decimal(smoothedK[idx]),
+      d: new Decimal(dLine[idx]),
+    };
+  },
+
+  calculateWilliamsR(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 14,
+  ): Decimal | null {
+    if (close.length < period) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = JSIndicators.williamsR(h, l, c, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateCCI(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 20,
+  ): Decimal | null {
+    if (close.length < period) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = calculateCCISeries(h, l, c, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateADX(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 14,
+  ): Decimal | null {
+    if (close.length < period * 2) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = JSIndicators.adx(h, l, c, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateAO(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    fast: number = 5,
+    slow: number = 34,
+  ): Decimal | null {
+    if (high.length < slow) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const res = calculateAwesomeOscillator(h, l, fast, slow);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateMomentum(
+    data: (number | string | Decimal)[],
+    period: number = 10,
+  ): Decimal | null {
+    if (data.length < period) return null;
+    const nums = data.map(toNumFast);
+    const res = JSIndicators.mom(nums, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateIchimoku(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    conversionPeriod: number = 9,
+    basePeriod: number = 26,
+    spanBPeriod: number = 52,
+    displacement: number = 26,
+  ) {
+    if (high.length < spanBPeriod) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const res = JSIndicators.ichimoku(
+      h,
+      l,
+      conversionPeriod,
+      basePeriod,
+      spanBPeriod,
+      displacement,
+    );
+    const idx = res.conversion.length - 1;
+    return {
+      conversion: new Decimal(res.conversion[idx]),
+      base: new Decimal(res.base[idx]),
+      spanA: new Decimal(res.spanA[idx]),
+      spanB: new Decimal(res.spanB[idx]),
+    };
+  },
+
+  calculatePivots(
+    klines: Kline[],
+    type: string = "classic",
+  ) {
+    return calculatePivots(klines, type);
+  },
+
+  calculateATR(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 14,
+  ): Decimal | null {
+    if (close.length < period) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = JSIndicators.atr(h, l, c, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateBollingerBands(
+    data: (number | string | Decimal)[],
+    period: number = 20,
+    stdDev: number = 2,
+  ) {
+    if (data.length < period) return null;
+    const nums = data.map(toNumFast);
+    const res = JSIndicators.bb(nums, period, stdDev);
+    const idx = res.middle.length - 1;
+    return {
+      middle: new Decimal(res.middle[idx]),
+      upper: new Decimal(res.upper[idx]),
+      lower: new Decimal(res.lower[idx]),
+    };
+  },
+
+  calculateChoppiness(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 14,
+  ): Decimal | null {
+    if (close.length < period) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = JSIndicators.choppiness(h, l, c, period);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateSuperTrend(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 10,
+    factor: number = 3,
+  ) {
+    if (close.length < period) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = JSIndicators.superTrend(h, l, c, period, factor);
+    const idx = res.value.length - 1;
+    return {
+      value: new Decimal(res.value[idx]),
+      trend: res.trend[idx],
+    };
+  },
+
+  calculateATRTrailingStop(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    period: number = 14,
+    multiplier: number = 3.5,
+  ) {
+    if (close.length < period) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const res = JSIndicators.atrTrailingStop(h, l, c, period, multiplier);
+    const idx = res.buyStop.length - 1;
+    return {
+      buy: new Decimal(res.buyStop[idx]),
+      sell: new Decimal(res.sellStop[idx]),
+    };
+  },
+
+  calculateOBV(
+    close: (number | string | Decimal)[],
+    volume: (number | string | Decimal)[],
+  ): Decimal | null {
+    if (close.length < 2) return null;
+    const c = close.map(toNumFast);
+    const v = volume.map(toNumFast);
+    const res = JSIndicators.obv(c, v);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateMFI(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    volume: (number | string | Decimal)[],
+    period: number = 14,
+  ): Decimal | null {
+    if (close.length < period + 1) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const v = volume.map(toNumFast);
+    const res = calculateMFI(h, l, c, v, period);
+    return new Decimal(res);
+  },
+
+  calculateVWAP(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    volume: (number | string | Decimal)[],
+    time?: number[],
+    anchor: { mode: "session" | "fixed"; anchorPoint?: number } = {
+      mode: "session",
+    },
+  ): Decimal | null {
+    if (close.length == 0) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const v = volume.map(toNumFast);
+
+    const res = JSIndicators.vwap(h, l, c, v, time, anchor);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateParabolicSAR(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    start: number = 0.02,
+    increment: number = 0.02,
+    max: number = 0.2,
+  ): Decimal | null {
+    if (high.length < 2) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const res = JSIndicators.psar(h, l, increment, max);
+    return new Decimal(res[res.length - 1]);
+  },
+
+  calculateVolumeProfile(
+    high: (number | string | Decimal)[],
+    low: (number | string | Decimal)[],
+    close: (number | string | Decimal)[],
+    volume: (number | string | Decimal)[],
+    rowCount: number = 24,
+  ) {
+    if (close.length == 0) return null;
+    const h = high.map(toNumFast);
+    const l = low.map(toNumFast);
+    const c = close.map(toNumFast);
+    const v = volume.map(toNumFast);
+
+    const res = JSIndicators.volumeProfile(h, l, c, v, rowCount);
+    if (!res) return null;
+
+    return {
+      poc: new Decimal(res.poc),
+      vaHigh: new Decimal(res.vaHigh),
+      vaLow: new Decimal(res.vaLow),
+      rows: res.rows.map((r) => ({
+        priceStart: new Decimal(r.priceStart),
+        priceEnd: new Decimal(r.priceEnd),
+        volume: new Decimal(r.volume),
+      })),
+    };
+  },
 };
